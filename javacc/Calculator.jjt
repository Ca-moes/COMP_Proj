options
{
    LOOKAHEAD=1;
}

PARSER_BEGIN(Calculator)

public class Calculator {
    public static void main(String[] args) throws ParseException {
        Calculator myCalc = new Calculator(System.in);
        SimpleNode root = myCalc.Program(); // returns reference to root node
        root.dump("");  // prints the tree on the screen
    }
}

PARSER_END(Calculator)

JAVACODE
void error_skipto(int kind) {
  ParseException e = generateParseException();  // generate the exception object.
  System.out.println("Error In while Expression. Printing stacktrace");
  System.out.println(e.toString());  // print the error message
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind);
    // The above loop consumes tokens all the way up to a token of
    // "kind".  We use a do-while loop rather than a while because the
    // current token is the one immediately before the erroneous token
    // (in our case the token immediately before what should have been
    // "if"/"while".
}

SKIP :
{
    " " | "\t" | "\r" | "\n"
}

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT |
  <"/**" ~["/"]> : IN_FORMAL_COMMENT |
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n"> : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}


TOKEN :
{
     < IMPORT : "import" >
    | < DOT : ".">
    | < SEMICOLON : ";">
    | < CLASS : "class">
    | < EXTENDS : "extends">
    | < OPENCURLY : "{">
    | < CLOSECURLY : "}">
    | < PUBLIC : "public">
    | < OPENPAR : "(">
    | < CLOSEPAR : ")">
    | < COMMA : ",">
    | < RETURN : "return">
    | < STATIC : "static">
    | < VOID : "void">
    | < MAIN : "main">
    | < STRING : "String">
    | < OPENBRACKET : "[">
    | < CLOSEBRACKET : "]">
    | < INT : "int">
    | < BOOL : "boolean">
    | < IF : "if">
    | < ELSE : "else">
    | < WHILE : "while">
    | < EQUAL : "=">
    | < AND : "&&">
    | < LESSTHAN : "<">
    | < PLUS : "+">
    | < MINUS : "-">
    | < MULT : "*">
    | < DIV : "/">
    | < TRUE : "true">
    | < FALSE : "false">
    | < THIS : "this">
    | < NEW : "new">
    | < NOT : "!">
    | < LENGTH : "length" >
    | < INTEGERLITERAL : (["0"-"9"])+>
    | < IDENTIFIER : ["a"-"z", "A"-"Z", "$", "_"](["a"-"z", "A"-"Z", "0"-"9", "$", "_"])* >
}

SimpleNode Program(): {}
{
  (ImportDeclaration())* ClassDeclaration() <EOF> { return jjtThis; }
}

void ImportDeclaration() : {}
{
  <IMPORT> <IDENTIFIER> (<DOT> <IDENTIFIER>)* <SEMICOLON>
}

void ClassDeclaration() : {}
{
  <CLASS> <IDENTIFIER> [<EXTENDS> <IDENTIFIER>] <OPENCURLY> (VarDeclaration())* (MethodDeclaration())* <CLOSECURLY>
}

void VarDeclaration() : {}
{
  Type() <IDENTIFIER> <SEMICOLON>
}

void Type() #void : {}
{
  <BOOL> | <INT> [<OPENBRACKET><CLOSEBRACKET>] | <IDENTIFIER>
}

void MethodDeclaration() #void : {}
{
  <PUBLIC> MD1()
}

void Param() : {}
{
  Type() <IDENTIFIER>
}

void Return() : {}
{
  <RETURN> Expression() <SEMICOLON>
}

void MD1() #void : {}
{
  (Type() <IDENTIFIER> <OPENPAR> [Param() (<COMMA> Param())*] <CLOSEPAR> <OPENCURLY> (LOOKAHEAD(2) VarDeclaration())* (Statement())* Return()<CLOSECURLY>) #ClassMethod |
  (<STATIC> <VOID> <MAIN> <OPENPAR> <STRING> <OPENBRACKET> <CLOSEBRACKET> <IDENTIFIER> <CLOSEPAR> <OPENCURLY> (LOOKAHEAD(2) VarDeclaration())* (Statement())* <CLOSECURLY>) #MainMethod
}

void IfElse() #void : {} {
  IfStatement() ElseStatement()
}

void IfStatement() : {} {
  <IF> <OPENPAR> Expression() #IfCondition <CLOSEPAR> Statement()
}

void ElseStatement() : {} {
  <ELSE> Statement()
}

void While() : {}
{
  try {
    <WHILE> <OPENPAR> Expression() #WhileCondition <CLOSEPAR> <OPENCURLY>
  } catch (ParseException e) {
    error_skipto(OPENCURLY);
  }
    (Statement())* <CLOSECURLY>
}

void Statement() #void : {}
{
  (<OPENCURLY> (Statement())* <CLOSECURLY>) |
  IfElse() |
  While() |
  LOOKAHEAD(2) (<IDENTIFIER> #Variable [<OPENBRACKET> Expression() <CLOSEBRACKET>] <EQUAL> Expression() <SEMICOLON>) #Assignment |
  (Expression() <SEMICOLON>)
}

void Expression() #void : {}
{
  RelationalExpression() (<AND> RelationalExpression() #AndExpression(2))*
}

void RelationalExpression() #void : {}
{
  AdditiveExpression() (<LESSTHAN> AdditiveExpression() #RelationalExpression(2))*
}

void AdditiveExpression() #void : {}
{
  MultiplicativeExpression() ((<PLUS> | <MINUS>) MultiplicativeExpression() #AdditiveExpression(2))*
}

void MultiplicativeExpression() #void : {}
{
  NotExpression() ((<MULT> | <DIV>) NotExpression() #MultiplicativeExpression(2))*
}

void NotExpression() #void : {}
{
  <NOT> NotExpression() #NotExpression | PrimaryExpression()
}

void PrimaryExpression() #void : {}
{
  PrimaryPrefix() (PrimarySuffix())*
}

void PrimaryPrefix() #void : {}
{
  Literal() | <THIS> #Variable | <IDENTIFIER> #Variable | (<OPENPAR> Expression() <CLOSEPAR>) | AllocationExpression()
}

void PrimarySuffix() #void : {}
{
  (<DOT> (<THIS> #DotExpression(2) | AllocationExpression() #DotExpression(2) | <IDENTIFIER> [MethodCall() #DotExpression(2)] | (<LENGTH> #MethodCall) #DotExpression(2))) | <OPENBRACKET> Expression() <CLOSEBRACKET> #ArrayAccess
}

void MethodCall() : {}
{
  <OPENPAR> [Expression() (<COMMA> Expression())*] <CLOSEPAR>
}

void Literal() #void : {}
{
  <INTEGERLITERAL> #IntegerLiteral | BooleanLiteral()
}

void BooleanLiteral() : {}
{
  <TRUE> | <FALSE>
}

void AllocationExpression() : {}
{
  <NEW> ((<INT> ArrayInit()) | (<IDENTIFIER> <OPENPAR> <CLOSEPAR>))
}

void ArrayInit() : {}
{
  <OPENBRACKET> Expression() <CLOSEBRACKET>
}
